---
layout: ru_post
title: Магия за Корутинами (Coroutine) в Unity.
---

Корутины в Unity всегда вызывали много вопросов, и мало кто полностью понимает, на каких принципах основан механизм их действий.

### Разбираемся с IEnumerator

При использовании Корутин вы скорее всего заметили, что им немного помогает интерфейс `IEnumerator` и реализация итераторов в CLR,
поэтому стоит сначала разобраться как работают эти вещи.
Изначально интерфейсы `IEnumerator` и `IEnumerable` предполагались для работы с коллекциями элементов, вроде списков или массивов.
Даже строку можно представить как коллекцию символов. Часто коллекции перебирают с помощью конструкции `foreach` statement:

{% highlight C# %}
foreach(char c in "coroutine")
  Debug.Log(c);
{% endhighlight %}

Хитрое выражение `foreach` работает с интерфейсом `IEnumerable`. Все, что умеет делать этот интерфейс - выдавать `IEnumerator`,
объект, который знает как перебирать коллекцию. Он рассказывает небольшую историю о том, какой элемент идет следующим, и остались ли еще
непосещенные элементы. Выглядит это примерно так:

{% highlight C# %}
class Enumerable // Реализует IEnumerable или IEnumerable<T>
{
  public Enumerator GetEnumerator() {...}
}

class Enumerator // Реализует IEnumerator или IEnumerator<T>
{
  public IteratorVariableType Current { get {...} }
  public bool MoveNext() {...}
}
{% endhighlight %}

И вот на что на самом деле похоже выражение `foreach` после компиляции:

{% highlight C# %}
using (var enumerator = "coroutine".GetEnumerator())
  while (enumerator.MoveNext())
  {
  var element = enumerator.Current;
  Console.WriteLine (element);
  }
{% endhighlight %}

### Итераторы

Это самая интересная часть. Мы почти дошли до самих Корутин.
В нашем примере, выражение `foreach` - это потребитель итерации, в то время как итератор - это производитель.
Взгляните на код:

{% highlight C# linenos %}
...
void Start()
{
  foreach(int fibNum in Fibs(6))
    Debug.Log(fibNum);
}

IEnumerable<int> Fibs(int fibCount)
{
   for(int i = 0, prevFib = 1, curFib = 1; i < fibCount; i++)
   {
		yield return prevFib;
	 
		int newFib = prevFib + curFib;
		prevFib = curFib;
		curFib = newFib;
   }
}
{% endhighlight %}

Если посмотреть на 12 строчку, то можно увидеть выражение `yield`, в то время как функция Fibs возвращает `IEnumerable<int>`, 
и все это в целом составляет крайне интересную конструкцию. Обычное выражение `return` возвращает определенное значение из вашей функции,
в то время как `yield return` выдает вам __следующий элемент__ предполагаемой коллекции. Каждый раз, когда выполнение кода доходит до
выражения `yield return`, контроль отдается вызывающей функции, и при следующем вызове функции (в нашем случае Fibs), выполнение кода
продолжается с предыдущего места "разрыва". Компилятор преобразует метод `Fibs(...)` в приватный класс, который превращает логику
`yield return` в метод `MoveNext` и свойство `Current`.
При вызове метода мы на самом деле __создаем объект класса, сгенерированного компилятором__ и код внутри функции не выполняется!
Логика функции будет выполняться только при переборе этой "мнимой" коллекции!

Еще есть выражение `yield break`, позволяющее прервать итерацию.

### Вернемся к Корутинам

Теперь нетрудно проследить, как эта логика реализуется в Корутинах в Unity.
Обычно в Корутинах возвращают различные объекты, отражающие временные интервалы, или `null`, в случае если необходимо продолжить выполнение
корутины в следующем кадре. На самом деле, Unity использует эти объекты для того, чтобы знать когда ей нужно вызывать `MoveNext()` в очередной раз!
Вот как это обычно происходит:

{% highlight C# linenos %}
void Start()
{
    WaitForSeconds delay = new WaitForSeconds(1f);
    StartCoroutine(TestCoroutine(delay));
}

IEnumerator TestCoroutine(WaitForSeconds delay)
{
    while (true)
    {
        Debug.Log("tick");
        yield return delay;
    }
}
{% endhighlight %}

Мы возвращаем объект `WaitForSeconds` с помощью выражения `yield return`, и по нему Unity определяет время задержки.
Сообщение "tick" появится в консоли один раз сразу, и будет появляться каждую секунду после этого. Попробуйте перетащить вызов `Debug.Log(..)`
`yield return` и посмотрите что произойдет.

Теперь посмотрим, что произойдет если просто вызвать метод `TestCoroutine`.

{% highlight C# linenos %}
void Start()
{
    WaitForSeconds delay = new WaitForSeconds(1f);
    TestCoroutine(delay);
}
{% endhighlight %}

Можно подумать, что ничего не происходит, но на самом деле мы создали объект - итератор, который теперь живет в куче (но мы сразу же потеряли на него ссылку).
Для интереса можно сделать так:

{% highlight C# linenos %}
void Start()
{
	IEnumerator rator = TestCoroutine(new WaitForSeconds(1f));
	for (int i = 0; i < 5; i++)
	{
       rator.MoveNext();
	}
}
{% endhighlight %}

Теперь сообщение "tick" выводится пять раз подряд без задержки.
На самом деле никакой магии в Корутинах нет, но от этого они не становятся менее интересными.

### На заметку

* Запуск корутины - это процесс создания итератора, который перебирает мнимую коллекцию элементов.
* Значения, которые возвращает этот итератор используются для определения величны задержки между вызовами метода `MoveNext`.